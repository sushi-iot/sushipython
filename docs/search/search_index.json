{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SushiPython IoT Framework","text":"<p>OS-like firmware for ESP32 \ud83d\udc1f A complete environment: Web UI, Menus &amp; Drivers out-of-the-box for MicroPython \ud83d\udc0d From breadboard to real projects \ud83d\udee0\ufe0f\ud83d\ude80 SushiPython IoT is a firmware framework for boards based on ESP32 SoC, providing an environment that integrates solid system management with MicroPython.</p> <p>It is useful for students and makers to accelerate projects by using reliable building blocks to manage core functions, allowing you to focus on application development without getting lost in low-level system details.</p> <p>New here? Take a look at a few real project examples to see SushiPython IoT in action.</p>"},{"location":"#main-resources","title":"Main resources","text":"<ul> <li>Full examples &amp; projects</li> <li>Firmware download</li> <li>SushiPython Instagram page</li> <li>Sushi IoT Board</li> <li>Sushi-IoT on HACKADAY</li> <li>SushiBoard Instagram page</li> </ul>"},{"location":"#applications","title":"Applications","text":"<ul> <li>Student experiments</li> <li>Home automation systems</li> <li>IoT hubs</li> <li>Alarm systems</li> <li>Domotics servers</li> <li>Remote monitoring and data logging systems (e.g., weather stations)</li> <li>Local and remote control systems (via local interface, web interface, or modem)</li> </ul>"},{"location":"#overview","title":"Overview","text":""},{"location":"#features","title":"Features","text":"<p>Works on very common commercial boards based on ESP32 SoC, widely available online for DIY electronics projects.</p> <p>It simplifies development:  </p> <ul> <li>Hardware management: Wi-Fi, LCD, keyboard, modem, I/O expansion, relays, power detection, battery level, buzzer.</li> <li>Software features: System management via web UI (network and system settings, logs, status, etc.) and a physical interface for on-device menus.</li> <li>Embedded MicroPython environment: Users can run their own scripts freely, while built-in libraries provide optional system management features.</li> <li>Embedded high-level MicroPython libraries for rapid access to hardware and software functions (custom menus, web pages, I/O expansion, SMS, HTTP requests, etc.).</li> </ul> <p>Manages all essential components typically present in an IoT system, regardless of the specific application:</p> <ul> <li>Physical interface management (keyboard, display, status LEDs)</li> <li>Wireless connection as client or access point</li> <li>Drivers for all hardware components present on the board (I/O expander, modem, etc.)</li> <li>Web interface with user-level access (web server and UI)</li> <li>Modular menu management for physical interface</li> <li>High-level API for many typical functions: HTTP requests, SMS, GSM calls, web server extension, I2C communication, etc.</li> </ul>"},{"location":"#code-demo","title":"Code Demo","text":"<p>Manage relays via a custom menu</p> <p>Custom menu integration</p> <p> </p>"},{"location":"#workflow","title":"Workflow","text":"<p>Typical Sushi IoT Project Workflow</p> Step #1Prepare your board Step #2Start and set up Step #3Start coding Step #4Benefit from the Sushi API"},{"location":"#credits","title":"Credits","text":"<p>This project embeds MicroPython, a lean and efficient implementation of Python 3 optimized for microcontrollers. We acknowledge and thank the MicroPython developers and contributors for their outstanding work.  </p>"},{"location":"#contacts","title":"Contacts","text":"<p>If you are interested in the Sushi IoT project or have any questions, feel free to contact me at \"mo.iot.wiz[at]gmail[dot]com\"</p>"},{"location":"coding/","title":"SushiPython MicroPython interface","text":""},{"location":"coding/#micropython-introduction","title":"MicroPython introduction","text":"<p>SushiPython integrates the MicroPython interpreter, giving you full access to the built-in firmware modules and the extensive set of libraries available online. Here we focus on the most important base concepts. </p>"},{"location":"coding/#for-beginners","title":"For beginners","text":"<p>If you are new to MicroPython development, the advice is follow these steps:</p> <ol> <li>Connect your board with USB cable</li> <li>Choose a user interface for MicroPython scripting</li> <li>Browse the examples section where you can start play with some scripts ready to test and modify.</li> </ol> <p>Resources:</p> <ul> <li>SushiPython MicroPython interface</li> </ul>"},{"location":"coding/#connect-to-the-board","title":"Connect to the board","text":"<p>The first step to start coding is to connect to the MicroPython REPL interface. There are basically two alternatives to program your scripts on the board:</p> <ul> <li> <p>Connect with USB cable directly to the micro board using the USB/UART REPL interface.   This is the most common, quick, and reliable solution to program your board. If you have a PC and no problems connecting by cable to the board, this is the best way.</p> </li> <li> <p>Connect via Web interface (WebREPL).   WebREPL is an alternative. From our tests it works, although there are still some issues and aspects to improve before recommending it as the best solution. Even in the MicroPython project it is considered experimental, but it will likely benefit from future improvements.   </p> </li> </ul>"},{"location":"coding/#choose-a-user-interface","title":"Choose a user interface","text":"<p>This section is for those who have no experience with MicroPython </p> <p>Once the board is connected to your PC, you can choose among several user interfaces to develop your scripts. The REPL interface is an interpreter that executes MicroPython commands, allowing you to interact directly with the device. Through REPL, you can also access commands to read and write files on the device\u2019s internal memory, which is managed by a file system available in MicroPython.</p> <p>Although REPL can be used from any serial terminal that opens the COM port, working at such a low level quickly becomes impractical for development beyond simple tests.</p> <p>For this reason, utilities are available that provide a higher-level interface, making it easier to perform tasks such as:</p> <ul> <li>Save Python files to the device memory (usually <code>.py</code> files), including: <ul> <li>Your application script files  </li> <li>New classes or MicroPython components to add functionality to the device</li> </ul> </li> <li>Open and edit files directly on the device</li> <li>Run the <code>.py</code> scripts in the device</li> <li>Perform other actions, like restarting the device to test startup behavior after adding auto-run scripts</li> </ul> <p>Some common interfaces for MicroPython development include:</p> <ul> <li>Arduino Lab for MicroPython \u2013 Arduino solution for MicroPython development  </li> <li>Thonny \u2013 Simple interface, easy to use even for beginners  </li> <li>mpremote \u2013 Command-line tool developed for MicroPython. Great for advanced users who prefer working with their own editor and sending commands from the prompt (Windows) or bash (Linux). Also useful for running scripts directly on the device.</li> </ul> <p>The choice of interface is up to you. In our examples and tests, we often relied on Thonny.</p>"},{"location":"coding/#auto-run-a-script","title":"Auto run a script","text":"<p>After you develop a script that performs some function, it is typical to want it to run automatically when the device starts. It is important to know that MicroPython automatically runs two scripts at every boot:</p> <ul> <li>boot.py: typically contains system and hardware initialization commands.  </li> <li>main.py: this is the main script executed to run your application. Here is where you put your code or run other \".py\" scripts you created.  </li> </ul> <p>These two scripts can be placed, like any other \".py\" file, into the file system using your favourite MicroPython UI interface.</p>"},{"location":"coding/#sushipython-micropython-interface_1","title":"SushiPython Micropython interface","text":"<p>SushiPython extends the base MicroPython interface with additional modules that allow you to quickly perform specific tasks. Beyond the system tasks integrated into the framework these MicroPython modules offer another advantage: they speed up development by reducing the complexity of common operations to a minimum. For example, with just a few lines of code you can:</p> <ul> <li>send or receive an SMS to remotely control a device, such as switching a light on or off</li> <li>integrate a local user interface menu to manage settings directly on the device</li> </ul> <p>The MicroPython modules embedded in SushiPython fall into two categories:</p> <ul> <li>SushiPython core module - the core of the SushiPython MicroPython interface, developed in C and providing all the framework\u2019s native extensions.</li> <li>Extension modules - classic \u201c.py\u201d modules embedded in the firmware (as frozen modules). They rely on MicroPython interface in the background to perform the most common operations in the simplest way possible.</li> </ul>"},{"location":"coding/#help","title":"Help","text":"<p>To display a quick reference, from the MicroPython REPL call: </p> <pre><code>&gt;&gt;&gt; sushi.help()\n</code></pre> <p>or see the result in SushiPython IoT MicroPython quick reference.</p>"},{"location":"coding/#examples","title":"Examples","text":"<p>See here all SushiPython MicroPython examples</p>"},{"location":"coding/#frozen-modules","title":"Frozen modules","text":"<p>Frozen modules can be wrapped or extended by the MicroPython interface. See here all actual modules source code</p>"},{"location":"getting_started/","title":"Getting started to SushiPython IoT Framework","text":""},{"location":"getting_started/#1-get-the-firmware","title":"1. Get the firmware","text":"<p>In SushiPython download page there is a table with all the releases for the supported boards. To get the latest features and fixes, it's recommended to use the latest stable version available.  </p>"},{"location":"getting_started/#2-flash-the-firmware","title":"2. Flash the firmware","text":"<p>Flashing the firmware can vary depending on the specific board you are using (in that case please check the producer documentation for more details).  </p> <p>We document here 2 options to flash the firmware that can fit on ESP32DevKitC-V4 and most ESP32 boards.  </p>"},{"location":"getting_started/#21-flash-by-online-tool","title":"2.1. Flash by ONLINE tool","text":"<p>Espressif provides an online tool that, using modern browser functions, can connect to your board via USB/COM port. The online tool is probably the easiest way to flash the firmware, but it's a \"young\" feature and depending on your system/browser/chip version may not work. If you have troubles, do not waste too much time on it; switch to the OFFLINE procedure, which is more reliable across all conditions.</p>"},{"location":"getting_started/#steps","title":"Steps","text":"<ol> <li>Plug your ESP32 board via USB into your PC.  </li> <li>Open the ESP Flash Tool in the browser.  </li> <li>Select 115200 as baud rate. Higher baud rates can cause issues; if you experience problems like \"Error: No serial data received\", switch to 115200.  </li> <li>Click \"Connect\" in the \"Program\" section and select the ESP32 board COM port. In the console, you should see the chip model and other info if the device is properly connected.  </li> <li>Start the board in boot mode (only if the program interface does not appear automatically).   <p>On the board: press the boot button, hold it, then press and release the reset button. If the step is successful, the web interface should display \"Connected to device:\" with all the buttons to program the board.</p> </li> <li>Press \"Erase Flash\" (recommended, especially for the first firmware load).  </li> <li>Select the firmware file (use the button on the right, not \"Add\"), set the Flash address to \"0\", and press \"Program\".</li> </ol>"},{"location":"getting_started/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>If \"Error: No serial data received\" appears, use the lowest baud rate (115200).  </li> <li>If you see \"flash corruption\" in REPL after firmware download, reinstall the firmware using \"Erase Flash\".  </li> <li>If the chip is detected but Erase/Program fails, it is probably not in BOOT mode. Boot mode is automatic if the chip is blank/new; otherwise, follow step 5 carefully to reset the device into boot mode.  </li> </ul> <p>Tip: For every retry, refresh the tool page to start clean, and possibly unplug/replug the device.</p>"},{"location":"getting_started/#22-flash-by-offline-tool","title":"2.2. Flash by OFFLINE tool","text":"<p>Download the official Espressif tool for your system: ESPTOOL. For example, here you can get the .exe version of the tool. This is an easier alternative compared to the Python \".py\" version of the tool, which you can find here. If you use \"esptool.py\" replace \"esptool\" with \"esptool.py\" in all the following commands.</p>"},{"location":"getting_started/#erase-the-chip","title":"Erase the chip","text":"<p>This is required especially when you are flashing the firmware for the first time.</p> <pre><code>esptool erase_flash\n</code></pre>"},{"location":"getting_started/#flash-the-firmware-file","title":"Flash the firmware file","text":"<p><code>esptool write_flash 0x0 FIRMWARE.bin</code></p> <p>Where \"FIRMWARE\" is the firmware .bin file that you downloaded. See SushiPython firmware download.</p>"},{"location":"getting_started/#troubleshooting_1","title":"Troubleshooting","text":"<ul> <li>esptool fails to detect the correct COM port: specify it with the \"--port\" option in front of the command.</li> </ul> <pre><code>esptool --port PORTNAME ...\n</code></pre> <p>Where PORTNAME: - On Linux, usually something like <code>/dev/ttyUSB</code>. - On Mac, usually something like <code>/dev/cu.usbmodem01</code>. - On Windows, usually something like <code>COM5</code>.  </p> <p>If these steps don't work, consult the esptool documentation from Espressif:</p> <ul> <li>esptool basic options </li> <li>esptool documentation</li> </ul>"},{"location":"getting_started/#23-test-the-firmware","title":"2.3. Test the firmware","text":"<p>After successfully loading the firmware, you can quickly check that everything is working by connecting to the MicroPython REPL.</p> <p>You have two options:</p> <ul> <li>Serial tool: connect with any serial terminal to the USB port.   See the coding section of the manual for details.</li> <li>Web tool: use the online COM monitor provided by Espressif on the same page as the ESP Flash Tool.</li> </ul> <p>Steps for the web tool:</p> <ol> <li>If you previously used it to flash the firmware, refresh the page.  </li> <li>In the Console section, set the baud rate to 115200, click Start, and select the COM port of your board.  </li> <li>On the device, press the RESET button.</li> </ol> <p>If everything works, you should see the device boot and the MicroPython REPL:</p> <pre><code>...\nMicroPython 495ce91-dirty on ... SushiPython firmware framework on ... with ESP32\nType \"help()\" for more information.\n&gt;&gt;&gt; \n</code></pre>"},{"location":"getting_started/#3-setup-and-wi-fi-connection","title":"3. Setup and Wi-Fi connection","text":"<p>This step is optional if you plan to start coding the device through the USB REPL interface.</p> <p>When the firmware is freshly flashed, the board starts Wi-Fi in access point mode. By scanning available networks, you should see an SSID like \"Sushi-...\" (the suffix is the device MAC address).</p> <p>You can connect your PC or smartphone to this Wi-Fi network and open the web interface at: <code>http://192.168.1.100</code> </p> <p>\u26a0\ufe0f Use http://, not https:// \u2014 HTTPS is supported but not enabled by default.</p> <p>Default network settings:</p> <ul> <li>SSID: \"Sushi-...\"  </li> <li>Password: (empty) </li> <li>IP address: \"192.168.1.100\"  </li> <li>User: \"root\"  </li> <li>Password: \"1976\"  </li> </ul> <p>From the web interface, you can adjust the base system settings and OPTIONALLY configure the device to connect to your Wi-Fi network. For more details about SushiPython web interface, see the system setup section.</p>"},{"location":"getting_started/#4-start-coding","title":"4. Start coding","text":"<p>Once the device is configured, you can start coding with your preferred MicroPython interface. In this guide, the examples use Thonny, but several alternatives are available.  </p> <p>For more details, see the coding section.</p>"},{"location":"manual/","title":"SushiPython IoT-Framework Software Manual","text":"<p>This guide refers to SushiPython latest firmware versions.</p>"},{"location":"manual/#coding","title":"Coding","text":"<p>SushiPython embeds the MicroPython REPL interface, for coding refer to the SushiPython coding.</p>"},{"location":"manual/#integrated-tasks-components","title":"Integrated tasks &amp; components","text":"<p>SushiPython integrates some common system tasks and software components that can be useful to speed up development.</p> Task name Description Requirements Wi-Fi Wi-Fi network connection management ESP32 chip only Web interface Web user interface accessible by a browser ESP32 chip only Setup System setup via configuration file ESP32 chip only Log &amp; Events System log and event register management ESP32 chip only System health Monitor system status.Log traces, store to file, and send device status remotely.Manage status LEDs - (OPTIONAL) External LEDs - (OPTIONAL) Voltage divider for ADC inputs to read battery level and power status On-device interface On-device user interface with screen and keypad - 4-button keypad - OLED screen Modem Modem management to enable high-level functions like sending/receiving SMS, performing HTTP GET/POST Modem module Temperature Manage temperature sensors Temperature sensor Data manager Manage and send data remotely via HTTP POST, switching automatically between Wi-Fi and modem - (OPTIONAL) Modem"},{"location":"manual/#wi-fi-management","title":"Wi-fi management","text":"<p>The wi-fi management let setup the device to work in 2 ways:</p> <ul> <li>Act as wi-fi access point</li> <li>Connect to am existing wi-fi network</li> </ul> <p>The setup can be done by the web-interface.</p> <p>Default network settings</p> <ul> <li>Wi-fi mode: Access point</li> <li>Network SSID: \"Sushi-...\"</li> <li>Network password: \"\"</li> <li>IP address: 192.168.1.100</li> </ul> <p>Extra functions</p> <ul> <li> <p>It is always possible to force the Wi-Fi to run in access point mode by holding the designated button for about 15 seconds: after that time the Wi-Fi will switch to access point mode.  So hold the button pressed and after 15-20 seconds scan the local Wi-Fi networks: you should detect the \"SushiPython-IoT\" network. Note that this does not permanently reset the device to factory settings: it only forces Wi-Fi to start in AP mode with default network settings (IP address <code>192.168.1.100</code> and no password). At the next micro reboot (reset button pressed or power off), Wi-Fi will start again according to the saved configuration. The specific button depends on the CPU board:</p> <ul> <li>ESP32DevKitC board: use the onboard \"BOOT\" button (looking at the ESP32 board with USB connector in the bottom, it is the button on the right).</li> </ul> </li> <li> <p>The system parameter powersave_time_wifi_off_min defines the timeout (in minutes).  If the device cannot connect to the configured Wi-Fi network (or, in AP mode, no client is connected) for longer than this time, the wireless hardware is switched off to save energy. Reconnection can then be done either by restarting the device or using the on-device interface.</p> </li> </ul>"},{"location":"manual/#web-interface","title":"Web interface","text":"<p>The web interface is divided into the following sections:</p> <ul> <li>SETTINGS: contains all system settings  </li> <li>STATUS: displays system information  </li> </ul> <p>Access is protected by user levels with 3 profiles. HTTPS is supported (default is HTTP).  </p> <p>Default users</p> User name Grants Default password user Read-only access \"1234\" admin Read-write access with some limitations \"2801\" root Full read-write access including system updates \"1976\""},{"location":"manual/#system-setup","title":"System setup","text":"<p>The SushiPython IoT Framework can be configured either through the web interface or via the MicroPython REPL interface. Basic settings are available as user controls directly in the web interface, while all settings (both basic and advanced) can be managed through a configuration file. This configuration file can be saved or loaded from the web UI using the controls at the bottom of the Settings section, and it can also be accessed from the MicroPython file system and API.</p>"},{"location":"manual/#factory-restore","title":"Factory restore","text":"<ul> <li>If you lose Wi-Fi connection and just need to access the web UI, you can force AP mode by pressing the dedicated onboard button (see Wi-Fi extra functions).  </li> <li>A full factory restore can be performed by sending a command from the MicroPython REPL, see SushiPython coding.  </li> </ul>"},{"location":"manual/#log-events","title":"Log &amp; Events","text":"<p>System log and events can be useful to monitor &amp; debug the system working.  Both can be accessed by the web-interface in the status page. Log can be enabled even from the MicroPython REPL interface.  Logs are cleared at every system restart while events are stored into a file. The max events file size is defined by the configuration parameter event_register_size_kb.</p>"},{"location":"manual/#system-health-monitor","title":"System health &amp; monitor","text":"<p>System health is a component useful to monitor the device status in different ways:</p> <ul> <li>Read the battery level and main power supply status. Require to connect battery and power to 2 ADC input with proper external resistor divider. For pinout details see Sushi-board or your board hardware manual. Configuration parameter: battery_enable</li> <li>Trace to log the system status (configuration parameter system_info_log_frequency_min).</li> <li>Store to file the system status (configuration parameters system_info_store_frequency_min and system_info_csv_filter).</li> <li>Send remotely the device status by http POST. Useful for example to monitor remotely an IoT device. This function requires setting the parameters system_info_send_http_post_frequency_min (frequency) and http_post_delivery_address (destination). </li> <li>Manage status LEDs. Let monitor the status by LEDs connected to the device.   <ul> <li>System status: function enabled by system_status_led parameter. 1 slow blink indicates OK, otherwise it's an error state. </li> <li>Wi-Fi status: function enabled by wifi_status_led parameter. 1 slow blink indicates client connected; quick continuous blink indicates access point mode; otherwise it's an error state. </li> </ul> </li> </ul>"},{"location":"manual/#on-device-interface","title":"On-device interface","text":"<p>This component manages a system menu accessible by a screen and a keypad directly on the device. Basically the following submenus are present:</p> <ul> <li>Diagnostic: several diagnostic info about the device, like battery level, temperature, etc.</li> <li>System info: versions and date-time info.</li> <li>Wi-Fi: Wi-Fi connection status, IP, option to force Wi-Fi off or in access point mode.</li> <li>Modem: modem status and network info.</li> </ul> <p>Configuration parameters: keyboard_enable, lcd_enable, ioex_enable.</p> <p>The standard menu management uses a 4 buttons keyboard (keyboard_enable = 4) to navigate: NEXT, PREVIOUS, BACK, ENTER.</p> <p>The menu can be extended with application specific submenus by SushiPython coding.</p>"},{"location":"manual/#modem-management","title":"Modem management","text":"<p>Modem management component:</p> <ul> <li>Perform the background tasks to manage the modem by AT commands, including SIM management (PIN, SMS center, APN, etc.). This includes a quite reliable monitor of the modem status, performing all the actions to keep the modem always available and working properly. To achieve maximum reliability, it is recommended to also connect the MOS-controlled modem power control.</li> <li>Enable the SushiPython API to easily perform high-level functions like send/receive SMS, perform HTTP GET/POST, and trigger actions when calls from certain numbers are received. See SushiPython coding.</li> </ul> <p>Anyone who worked on low-level modem management knows how tricky it can be to perform all the required tasks reliably. This component makes common operations quite easy.</p>"},{"location":"manual/#temperature-sensor","title":"Temperature sensor","text":"<p>This component simply manages one or more temperature sensors that can be read in different ways: in the system status, in the user menus, or via SushiPython coding. Configuration parameter: ext_temperature_sensor_enable.</p>"},{"location":"manual/#data-manager","title":"Data manager","text":"<p>In an IoT application it is common to have data to send remotely to some server (e.g., sensor data or alarms). This component manages all the tasks:</p> <ul> <li>Send data by HTTP POST.</li> <li>Put the data into a queue to manage multiple requests simultaneously.</li> <li>Manage different retries in case of errors.</li> <li>Try Wi-Fi if available; if not, switch automatically to use the modem (which requires a completely different and tricky management).</li> <li>Finally, fire a callback to give feedback when the process ends.</li> </ul> <p>SushiPython API provides an interface to this component, simplifying the process with minimal effort. Configuration parameters: http_post_delivery_address, use_wifi_for_http_post.</p>"},{"location":"manual/#system-parameters","title":"System parameters","text":"<p>To display a brief list with all parameters from the MicroPython REPL call <code>sushi_utils.list_params(...)</code>.    </p> <p>SYSTEM MODULE</p> <pre><code>&gt;&gt;&gt; sushi_utils.list_params('system')\n</code></pre> <p>WIFI MODULE </p> <pre><code>&gt;&gt;&gt; sushi_utils.list_params('wifi')\n</code></pre> <p>Or see the result in SushiPython MicroPython quick reference.</p>"},{"location":"manual/#hardware-compatibility-pinout","title":"Hardware compatibility &amp; pinout","text":"<p>Some of the tasks integrated into the SushiPython IoT Framework manage external hardware, so it's important to know which pins of the microcontroller are used to connect the external devices.</p> <p>The base platform is always an ESP32 SoC, but the exact pin mapping used to control external peripherals depends on the specific board you're using. To display a brief table with all board-specific pins, call the <code>sushi_utils.pinout()</code> function from the MicroPython REPL.</p> <p>Show boards list</p> <pre><code>&gt;&gt;&gt;sushi_utils.pinout()\n  Available boards:\n*  ID 0: ESP32-DevKitC on Sushi Board\n</code></pre> <p>Show board specific pinout</p> <pre><code>&gt;&gt;&gt;sushi_utils.pinout(0)  \n=== ESP32-DevKitC on Sushi Board [\"board_model\" ID: 0] ===\n...\n</code></pre> <p>Or see the result in SushiPython MicroPython quick reference.</p> <p>For more details, refer to your board\u2019s hardware manual:</p> <ul> <li>Sushi-IoT Board: see the Sushi-IoT Board Hardware Manual.  </li> <li>Standalone ESP32-DevKitC board: it uses the same pinout as the Sushi-IoT Board but you have to connect all the external devices yourself .</li> </ul>"},{"location":"manual/#issue-remarks","title":"Issue &amp; Remarks","text":""},{"location":"manual/#differences-vs-micropython","title":"Differences vs MicroPython","text":"<p>SushiPython manages some system/hardware tasks, the following table highlights some points to consider during MicroPython scripting. This table refers to the latest available version of SushiPython-MicroPython integration: SushiPython version.</p> MicroPython module Remarks ADC Disabled. The MicroPython implementation uses an older version of driver that is not compatible with the current SushiPython ADC management (most recent ESP32 drivers). Reactivate the ADC module is priority one. Wi-Fi SushiPython-IoT Framework manages Wi-Fi connections with all the most common options. Using the native MicroPython Wi-Fi implementation at the same time would cause a conflict, so to do this you first need to disable Wi-Fi in the SushiPython-IoT setup (wifi_mode = 0)."},{"location":"manual/#known-bugs","title":"Known bugs","text":"<p>During MicroPython testing some bugs arose. The plan is to update the embedded MicroPython implementation to remove them.</p> <p>MicroPython known bugs</p> MicroPython module Problem WebREPL WebREPL is working but it's an experimental feature. During testing, cases were experienced where it completely blocked the microcontroller (requiring a power cycle). time time.localtime() function returns the wrong year. Other fields are correct. <p>Report an issue to mo.iot.wiz@gmail.com</p>"}]}